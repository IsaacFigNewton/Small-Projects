assume "out" represents the output function for a NN with 2 hidden layers
let the sum function be defined as sum(var to increment, min (inclusive), max (exclusive), iterative equation)
let f indicate the currently read index node
let j represent the currently read node from the first hidden layer
let k represent the currently read node from the second hidden layer
let o indicate the currently read output node

if out[o] =    sum(k, 0, 2,
                sum(j, 0, 2,
                    sum(f, 0, 2, in[f] * weights[0][j][f])
                * weights[1][k][j])
            * weights[2][k][o])


then out[o] =   (
                    (
                        (in[0] * w[0][0][0]) +
                        (in[1] * w[0][0][1])
                    ) * w[1][0][0]) +
                    (
                        (in[0] * w[0][1][0]) +
                        (in[1] * w[0][1][1])
                    ) * w[1][0][1])
                ) * w[2][o][0] +
                (
                    (
                        (in[0] * w[0][0][0]) +
                        (in[1] * w[0][0][1])
                    ) * w[1][1][0]) +
                    (
                        (in[0] * w[0][1][0]) +
                        (in[1] * w[0][1][1])
                    ) * w[1][1][1])
                ) * w[2][o][1]

thus do/dw[0][0][0]
=               (
                    (
                        (in[0])
                    ) * w[1][0][0])
                ) * w[2][o][0] +
                (
                    (
                        (in[0])
                    ) * w[1][1][0])
                ) * w[2][o][1]

=               (in[0] * w[1][0][0]) * w[2][o][0] +
                (in[0] * w[1][1][0]) * w[2][o][1]

=               in[0] * (w[1][0][0]) * w[2][o][0] + w[1][1][0]) * w[2][o][1])

thus do/dw[1][0][0]
=               (
                    (
                        (in[0] * w[0][0][0]) +
                        (in[1] * w[0][0][1])
                    )
                ) * w[2][0][o]
=               (in[0] * w[0][0][0]) + (in[1] * w[0][0][1]) * w[2][0][o]
=               h[0][0] * w[2][o][0]

thus do/dw[2][o][0]
=               (
                    (
                        (in[0] * w[0][0][0]) +
                        (in[1] * w[0][0][1])
                    ) * w[1][0][0]) +
                    (
                        (in[0] * w[0][1][0]) +
                        (in[1] * w[0][1][1])
                    ) * w[1][0][1])
                )
=               (
                    h[0][0] * w[1][0][0]) +
                    h[0][1] * w[1][0][1])
                )
=               h[1][0]

***********************************************************************************************
and presumably out[o] for a NN with 3 hidden layers would be:
                (
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                        ) * w[1][0][0]) +
                        (
                            (in[0] * w[0][1][0]) +
                            (in[1] * w[0][1][1])
                        ) * w[1][0][1])
                    ) * w[2][0][0] +
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                        ) * w[1][1][0]) +
                        (
                            (in[0] * w[0][1][0]) +
                            (in[1] * w[0][1][1])
                        ) * w[1][1][1])
                    ) * w[2][0][1]
                ) * w[3][o][0] +
                (
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                        ) * w[1][0][0]) +
                        (
                            (in[0] * w[0][1][0]) +
                            (in[1] * w[0][1][1])
                        ) * w[1][0][1])
                    ) * w[2][1][0] +
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                        ) * w[1][1][0]) +
                        (
                            (in[0] * w[0][1][0]) +
                            (in[1] * w[0][1][1])
                        ) * w[1][1][1])
                    ) * w[2][1][1]
                ) * w[3][o][1]

making do/dw[0][0][0]
=               (
                    (
                        (
                            (in[0])
                        ) * w[1][0][0])
                    ) * w[2][0][0] +
                    (
                        (
                            (in[0])
                        ) * w[1][1][0])
                    ) * w[2][0][1]
                ) * w[3][o][0] +
                (
                    (
                        (
                            (in[0])
                        ) * w[1][0][0])
                    ) * w[2][1][0] +
                    (
                        (
                            (in[0])
                        ) * w[1][1][0])
                    ) * w[2][1][1]
                ) * w[3][o][1]
                
=               (
                    in[0] * w[1][0][0]) * w[2][0][0] +
                    in[0] * w[1][1][0] * w[2][0][1]
                ) * w[3][o][0] +
                (
                    in[0] * w[1][0][0] * w[2][1][0] +
                    in[0] * w[1][1][0] * w[2][1][1]
                ) * w[3][o][1]
                                                        
=               in[0] * 
                (
                    w[1][0][0]) * w[2][0][0] +
                    w[1][1][0] * w[2][0][1]
                ) * w[3][o][0] +
                (
                    w[1][0][0] * w[2][1][0] +
                    w[1][1][0] * w[2][1][1]
                ) * w[3][o][1]
                
making do/dw[1][0][0]
=               (
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                    ) * w[2][0][0]
                ) * w[3][o][0] +
                (
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                    ) * w[2][1][0]
                ) * w[3][o][1]
=               h[0][0] * (w[2][0][0] * w[3][o][0] + w[2][1][0] * w[3][o][1])


making do/dw[2][0][0]
=               (
                    (
                        (
                            (in[0] * w[0][0][0]) +
                            (in[1] * w[0][0][1])
                        ) * w[1][0][0]) +
                        (
                            (in[0] * w[0][1][0]) +
                            (in[1] * w[0][1][1])
                        ) * w[1][0][1])
                    ) * w[3][o][0]
=               (
                    (
                        h[0][0]
                        * w[1][0][0]
                    ) +
                    (
                        h[0][1]
                        * w[1][0][1]
                    )
                ) * w[3][o][0]
=               h[1][0] * w[3][o][0]

***************************************************************************************************

getSubsequentWeightsSum desired output:

with 3 layers (1 hidden layer/2 weight layers)
do/w[0][0][0]  w[1][o][0]
do/w[1][0][0]  1
do/w[2][0][0]  N/A

with 4 layers (2 hidden layers)
do/w[0][0][0]  w[1][0][0] * w[2][o][0] + w[1][1][0]) * w[2][o][1]
do/w[1][0][0]  w[2][o][0]
do/w[2][0][0]  1

with 5 layers (3 hidden layers)
do/w[0][0][0]   (
            w[1][0][0]) * w[2][0][0] +
            w[1][1][0] * w[2][0][1]
        ) * w[3][o][0] +
        (
            w[1][0][0] * w[2][1][0] +
            w[1][1][0] * w[2][1][1]
        ) * w[3][o][1]
do/w[1][0][0]  w[2][0][0] * w[3][o][0] + w[2][1][0] * w[3][o][1]
do/w[2][0][0]  w[3][o][0]

because the weight in each subsequent layer is the partial derivative,
of the partial derivative of any weight in the previous layer, just with respect to the current (desired)
weight, coding a scale-invariant way of finding the weights' slopes for the problem is intractable
without a library like SynPy that would let me find the partial derivatives of functions

since that might take more time to learn to use/implement than time left this summer,
I'm gonna spend my time on other pursuits